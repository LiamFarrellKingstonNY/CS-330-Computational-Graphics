CS 330 â€“ Computational Graphics and Visualization
Module Eight Portfolio Reflection

Liam Farrell

This repository contains my final 3D Scene project and Design Decisions document. This project demonstrates my ability to design, develop, and refine a fully rendered 3D scene using OpenGL concepts such as lighting, transformations, textures, and shader management.

How Do I Approach Designing Software?

When designing software, I begin by identifying the core objective and breaking the problem into manageable components. For this 3D scene project, I first considered the overall visual goal and then decomposed it into individual objects, lighting models, and transformations.

I approach design with structure in mind. I try to separate responsibilities (e.g., scene management, view management, mesh creation) and ensure that each component has a clear purpose. This helps maintain readability and scalability.

New Design Skills Developed

Through this project, I strengthened several design skills:

Spatial reasoning in 3D environments

Planning object transformations and coordinate systems

Designing reusable mesh and shader structures

Managing lighting models (ambient, diffuse, specular)

Organizing graphics pipeline components

This project required thinking visually and mathematically at the same time, which was a valuable shift from more traditional backend development work.

Design Process Followed

My design process followed these steps:

Define the scene goal and object composition

Sketch layout and object placement conceptually

Implement foundational objects and transformations

Integrate textures and materials

Add lighting and shading

Refine visual realism and fix rendering issues

Each milestone built on the previous one, reinforcing incremental design improvements rather than attempting to complete everything at once.

Applying This Design Approach in the Future

The modular, iterative design approach used in this project can be applied to future software development, especially large systems. Breaking complex systems into layers and responsibilities (such as rendering, logic, and input handling) is directly transferable to enterprise software, web applications, and security-based systems.

How Do I Approach Developing Programs?

When developing programs, I focus on building small, testable components and then integrating them gradually. I prioritize understanding how each section of code interacts with the larger system.

New Development Strategies Used

While working on this 3D scene, I used several new strategies:

Incremental rendering testing

Debugging shader and lighting calculations

Using transformation matrices effectively

Refining object scaling and positioning through iteration

Managing texture loading and memory considerations

Graphics programming required more experimentation compared to previous courses. Many issues (like lighting artifacts or incorrect normals) required analytical debugging and adjustments.

Role of Iteration

Iteration played a critical role in development. Rendering rarely worked perfectly on the first attempt. I frequently:

Adjusted lighting intensity

Refined material properties

Corrected transformation orders

Tuned object positioning

Each milestone improved the realism and stability of the final scene. My workflow evolved from trial-and-error to more intentional adjustments based on understanding of the graphics pipeline.

Evolution of My Coding Approach

Earlier milestones focused on simply getting objects to render. By the final project, I was more comfortable managing shader uniforms, lighting toggles, and modular code structure.

My development approach became:

More structured

More performance-aware

More visually analytical

More confident in debugging low-level graphics issues

How Can Computer Science Help Me Reach My Goals?

Computer science provides the technical foundation necessary to build scalable systems, solve complex problems, and create innovative solutions. Whether in software security, cloud systems, or visualization, the structured thinking required in CS strengthens both analytical and creative problem-solving skills.

This course expanded my understanding of how software interacts directly with hardware through the graphics pipeline, which deepened my appreciation for performance and system-level programming.

Educational Impact of Computational Graphics

Computational graphics strengthened:

Linear algebra application (matrices, vectors, transformations)

Mathematical modeling in real-time systems

Understanding of rendering pipelines

Visualization as a communication tool

These skills are applicable to advanced coursework in graphics, simulation, data visualization, and even cybersecurity (e.g., visualizing network activity or system behavior).

Professional Impact of Computational Graphics

From a professional perspective, this project demonstrates:

Ability to work with complex frameworks (OpenGL, shaders)

Comfort with debugging non-trivial technical issues

Experience designing modular software components

Understanding of performance considerations

Even outside of graphics-specific roles, the discipline required in this course translates directly to:

Game development

Simulation systems

Data visualization

UI/UX systems with 3D components

Technical problem-solving roles

This project reflects both technical growth and increased confidence in handling complex programming challenges.


